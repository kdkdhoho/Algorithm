# 개요

dx, dy 테크닉은 알고리즘 문제를 풀 때 **방향 , 동서남북, 상하좌우**라는 말이 나올 때 유용한 테크닉이다.
</br>또는 **BFS, DFS** 문제를 해결할 때에도 유용하게 쓰인다.
</br>따라서 활용성이 아주 높은 문제 해결 방법이다.

dx, dy할 때 d는 **델타**. 즉, 수학에서의 **변화량**을 뜻한다.

그래프 상에서 한 점에서 다른 한 점으로의 이동거리를 알기 위해서는 **dx**와 **dy**의 **두 값**을 알아야 한다.
</br>하지만 dx, dy 테크닉으로 하나의 값만으로 알 수 있게 된다.

# 방법

(x, y) 위치에서 시작하여 주어진 값으로 좌표를 이동시키려고 한다.

0 -> 동 -> (x+1, y)
</br>1 -> 남 -> (x, y-1)
</br>2 -> 서 -> (x-1, y)
</br>3 -> 북 -> (x, y+1)

위의 규칙을 통해 미리 배열을 정의하여 간단히 하나의 값으로 좌표를 이동시킬 수 있다.

```java
// 동 서 남 북
int[] dx = {1,  -1, 0, 0};
int[] dy = {0, 0,  -1, 1};

current_x += dx[input_num];
current_y += dy[input_num];
```

이렇게 미리 방향을 정하여 그 방향으로 이동할 수 있도록 하는 값을 더하여, index 값만으로 동서남북으로 방향을 이동할 수 있다.

# 방향 회전을 위한 dx, dy 정의 방법

이번에는 방향을 포함하는 dx, dy 테크닉에 대해 알아보자.

```java
// 동 서 남 북
int[] dx = {1,  -1, 0, 0};
int[] dy = {0, 0,  -1, 1};
```

기존 dx, dy 테크닉에서 동 = 0, 서 = 1, 남 = 2, 북 = 3 으로 치환하여 `int dir_num`에 값을 넣어주면 된다.

이는 단순하고 정확한 방법이지만 코드가 길어진다.
</br>조금 더 간결하게 코드를 작성하기 위한 아이디어를 생각해보자.

바로 동 -> 서 -> 남 -> 북이 아닌 **동 -> 남 -> 서 -> 북** 의 순서로 정의하면 오른쪽 방향으로 하나씩 이동하는 개념이 된다.

그래서 idx는 0, 1, 2, 3 이 순환되어야 한다.

때문에, `dir_num = (current_dir + next_dir) % 4`로 해주어 구현할 수 있다.

아래는 전체 코드이다.

```java
// 동 남 서 북
int[] dx = new int[]{1,  0, -1, 0};
int[] dy = new int[]{0, -1,  0, 1};

// rotate direction
dirNum = (dirNum + 1) % 4;

// move
nx = x + dx[dirNum];
ny = y + dy[dirNum];
```

> 다만, 반시계 방향은 `dirNum = (dirNum - 1) % 4;` 으로 할 경우 `dirNum`이 음수가 될 수 있다. 따라서 `dirNum = (dirNum + 3) % 4;` 으로 구현해주자.

# 꿀팁

만약 dx, dy를 **동, 서, 남, 북**으로 선언했다면, dir의 순서는 **0 2 1 3** 이 된다.

이 상태에서 시계방향으로 회전하는 매칭은 어떻게 하면 좋을까?

바로 `int[] turn = {2, 3, 1, 0}` 이렇게 `turn` 배열을 선언해주어, `dir = turn[dir]`으로 값을 정해주면 현재 위치를 넣어주면 turn 배열에의해 시계방향으로 90도 회전이 된다.

이는 180도 회전도 마찬가지로 매칭만 해주면 되므로 꿀팁이라고 할 수 있다.

# 조건에 따라 방향이 변하는 경우

n \* n 크기의 격자 위 (x, y) 위치에서 공이 상하좌우 중 한 방향으로 이동중이다.
이동 도중 격자 끝에 다다르면, 방향을 반대로 바꿔 다시 움직입니다.
1초에 한 칸씩 움직인다 했을 때, 10초 뒤 공의 위치는 어떻게 될까? 라는 문제는 어떻게 풀면 될까?

이번이 정말 180도 회전을 구현할 수 있는 문제이다.

정석은, **동 남 북 서** 의 순서로 구현하자. 그리고 180도 회전은 `dir = 3 - dir`로 구현하자.

> **동 남 서 북** 순으로 구현하여, `dir = (dir + 2) % 4`로 해도 이상 없다.
> </br>그리고 꿀팁인 _turn_ 배열을 사용해서 구현해도 된다.

# 결론

x, y 좌표의 이동거리를 미리 배열로 선언해주어 idx로서 이동거리를 구하자.

그리고 방향도 미리 번호에 따른 방향을 정해주어, 숫자로서 방향을 나타내자.

> 이렇게 보면 정말 컴퓨터적 사고의 결과물인 것 같다.
> </br>컴퓨터는 거리, 방향의 개념은 모르고 단순히 숫자만 알고 있으니 _컴퓨터가 알고있는 숫자로서 우리가 사용하는 거리, 방향의 개념을 사용하는 개념이 인상깊다._
