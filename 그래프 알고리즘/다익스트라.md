# 개요

다익스트라 알고리즘은 **특정 시작점에서 다른 모든 정점으로 가는 최단거리를 각각 구해주는** 알고리즘이다.
즉, 5개의 정점이 있고 1번 정점에서 출발한다고 가정하면, 1번에서 2~5번 정점으로 가는 최단거리를 모두 구해주는 것이다.

다른 정점까지의 거리는 모르지만, A라는 정점으로 가는 최단거리를 알고 있다고 가정하면, A를 거쳐 다른 지점으로 갈 수 있다면 **특정 지점 = A까지의 거리 + A에서 특정 지점까지의 거리**이게 된다.

다익스트라는 이러한 아이디어를 기반으로 설계된 알고리즘이다.

# 방법

1. 노드의 개수만큼 배열을 생성하고 시작점으로 지정한 인덱스는 0으로, 나머지는 아주 큰 값(Integer.MAX_VALUE)으로 설정한다.

2. 모든 배열 값을 우선순위 큐에 넣는다.

3. 거리값 중 최소값인 노드를 골라 제거한다.

4. **제거된 노드에서 이웃한 노드의 거리를 더한 값**과 **이웃한 노드의 값**을 비교하여 작은 값으로 갱신한다.

5. 우선순위 큐가 빌 때까지 3, 4번의 과정을 반복한다.

# 수도 코드

```java
function dijkstra(graph, source)
    set Q = Queue()

    for each vertex in graph
        Q.push(v)

    set dist[source] = 0
    while Q is not empty
        set u = vertex in Q with min dist
        Q.remove(u)

        for each neighbor v of u
            set alt = dist[u] + length(u, v)
            if alt < dist[v]
                set dist[v] = alt
```

# 시간복잡도

노드의 수를 V, 링크의 수를 E라고 했을 때, O(ElogV)가 된다.

다익스트라 알고리즘을 진행하면 각 노드를 한 번씩 보게 되는데, 이때 거리값이 변하면 우선순위큐에서의 순서가 계속 바뀌므로 링크의 수 \* 우선순위 큐 이용 시간복잡도가 되기 때문이다.

만약 우선순위 큐를 사용하지 않고, **for문을 이용해 최소값을 찾는 식**으로 구현한다면, 최소값에 해당하는 노드를 고르는 데 V번 소요되고, 이 과정을 총 V번 반복해야하기에 O(V^2)가 된다.

# 주의

하지만 **음수 가중치**가 있는 그래프에서는 다익스트라가 제대로 동작하지 않을 수 있다.

> 출처: https://www.codetree.ai/
