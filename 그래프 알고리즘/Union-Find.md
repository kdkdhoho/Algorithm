## 개요

여러 개의 원소가 있고, 여러 개의 집합이 있다고 가정해보자.

특정 원소가 **어떤 집합에 속해있는지 확인**하고, 특정 집합을 **합쳐야** 할 일이 있다면 **Union-Find** 자료구조를 사용하는 것이 좋다.

## 방법

- 모든 노드가 연결되어 있지 않는 상황에서 시작한다.
  그리고 `int[] groupNum` 을 선언해준다. 이는 그룹 번호를 의미하고, 따라서 배열의 각 원소 초기값은 자기 자신이 된다.

- **`union(int child, int parent)`** 함수를 사용하면, 두 노드가 같은 그룹에 속해있음을 표시해줄 수 있다.
  예를 들어 1과 3을 연결하려고 한다면, `union(1, 3): groupNum[1] = 3` 을 해주면 된다.
  마찬가지로 `union(5, 6): groupNum[5] = 6`은 5번 노드를 6번 노드를 가리키도록 한다.

- 이렇게 `union`을 이용해 두 노드를 하나의 그룹으로 합친다면, 배열의 원소값은 같은 그룹으로서의 의미 뿐만이 아니라, **실제 노드가 현재 가리키고 있는 부모 노드의 번호**가 된다.

- **`find(int target)`**는 **`groupNum[target] == target`**이 될 때까지 탐색하여, 즉 하나의 노드의 부모 노드를 찾을 수 있다.
  이것을 이용하여, `union(5, 1)`을 선언했을 경우를 생각해보자.
  - 현재 5와 1은 각각 6과 3을 가리키고 있기에 5를 1을 바로 가리키도록 할 수 없다. 따라서 `find(5)`와 `find(1)`을 실행하여 두 노드가 가리키는 최상위 노드를 가져온다.
    이렇게 가져온 두 최상의 노드를 다시 한 번 `union()`을 통해 결과적으로 **6이 3을 가리키도록** 한다.
  - 이제 다시 `find(5)`를 하게 되면, 최종 노드인 **3**을 가리킨다.

## 코드

```
function union(x, y)
  set X = find(x), Y = find(y)
  uf[X] = Y
```

```
function find(x)
  if uf[x] == x
    return x
  return find(uf[x])
```

## 개선할 점

만약 모든 노드들이 한 줄로 이어진 자료구조에서는 Union-Find를 사용하는 것이 이득일까?

1부터 9까지의 노드가 마치 연결리스트처럼 한 줄로 이어져있다. 이때 만약 `find(1)`을 호출하면, 1부터 9까지 모든 노드를 거쳐 결국 9를 반환할 것이다.
이는 시간복잡도가 **O(N)**이게 되고, 굳이 Union-Find가 아닌 배열형태로 사용하는 것이 더 편하게 작용할 것이다.

그렇다면 이를 어떻게 해결할까?

바로 **한 줄 기차**가 아닌, **깊이를 1로**만드는 것이다.

위와 같은 예에서 결국 1부터 8까지는 모두 groupNum이 9로 동일하다.
</br>이는 1이 9를, 2도 9를, 3도 9를 ... 이런 식으로 각 노드가 바로 부모 노드를 가리키는 것으로 생각해도 같게 된다.

이런 식으로 데이터를 구성하면, 하나의 그룹에 노드가 많을 경우 타고 올라가는 경우도 생기지 않을 것이다.
</br>이를 **경로 압축**이라고 부르며, 이 방식을 사용하면 `union()`, `find()` 모두 **O(logN)**의 시간복잡도를 가진다.

### 개선된 코드

기존

```
function find(x)
  if uf[x] == x
    return x
  return find(uf[x])
```

코드에서

```
function find(x)
  if uf[x] == x
    return x

  // 루트노트가 아니라면
  set root_node = find(uf[x]) // 루트 노트를 찾도록 재귀함수 실행. 마침내 루트 노드 탐색 시 root_node에 대입
  uf[x] = root_node // 거쳐갔던 노드에 대해 바로 root_node를 가리키도록 설정
  return root_node // 찾아낸 루트 노드 반환
```

> 출처: https://www.codetree.ai/
